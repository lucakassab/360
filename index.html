<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>360 TB Stereo - Simples</title>
  <style>
    html, body {
      margin:0; height:100%; background:#000; overflow:hidden; font-family:system-ui, sans-serif;
      overscroll-behavior: none; /* evita pull-to-refresh global */
    }
    /* Só o canvas bloqueia gestos de navegação */
    canvas { display:block; width:100vw; height:100vh; touch-action: none; }
    /* UI aceita toque/click normal */
    #ui { position:fixed; top:10px; left:10px; z-index:20; display:flex; gap:8px; flex-wrap:wrap; touch-action: manipulation; }
    #ui * { font-size:14px; padding:8px; }
    #vrBtnContainer { position:fixed; bottom:10px; left:10px; z-index:20; touch-action: manipulation; }
    .hint { position:fixed; right:10px; bottom:10px; color:#bbb; font-size:12px; z-index:10; pointer-events:none; }
  </style>
</head>
<body>
  <div id="ui">
    <select id="imgSel"></select>
    <button id="gyroBtn">Imersivo (iOS)</button>
    <button id="vrBtn">VR (Android)</button>
  </div>
  <div id="vrBtnContainer"></div>
  <div class="hint">TB = topo=olho esquerdo. Se o teu vier invertido, troca no split.</div>
  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from 'https://esm.sh/three@0.165.0';
    import { DeviceOrientationControls } from 'https://esm.sh/three-stdlib@2.30.2/controls/DeviceOrientationControls.js?deps=three@0.165.0';
    import { VRButton } from 'https://esm.sh/three@0.165.0/examples/jsm/webxr/VRButton.js';

    const IMAGES = [
      'https://raw.githubusercontent.com/lucakassab/360/master/image_2_Stereo.jpg',
      'https://raw.githubusercontent.com/lucakassab/360/master/image_3_Stereo.jpg',
      'https://raw.githubusercontent.com/lucakassab/360/master/image_4_Stereo.jpg'
    ];

    const canvas = document.getElementById('c');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, powerPreference:'high-performance' });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = false;

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0,0,0.1);
    camera.rotation.order = 'YXZ'; // evita roll no mouse/desktop

    const sphereGeom = new THREE.SphereGeometry(50, 64, 64);
    sphereGeom.scale(-1, 1, 1); // olhar pra dentro

    let controls = null;
    let monoSphere = null, leftSphere = null, rightSphere = null;
    let mode = 'mono'; // 'mono' | 'ios' | 'webxr' | 'cardboard'
    let currentIndex = 0;

    async function loadStereo(index){
      const src = IMAGES[index];
      const img = await loadImage(src);
      const { leftTex, rightTex, monoTex } = splitStereoToTextures(img);
      setupTex(leftTex); setupTex(rightTex); setupTex(monoTex);

      if(!monoSphere) {
        monoSphere = new THREE.Mesh(sphereGeom, new THREE.MeshBasicMaterial({ map: monoTex }));
        scene.add(monoSphere);
      } else { monoSphere.material.map = monoTex; monoSphere.material.needsUpdate = true; }

      if(!leftSphere) {
        leftSphere = new THREE.Mesh(sphereGeom, new THREE.MeshBasicMaterial({ map: leftTex }));
        leftSphere.layers.set(1); scene.add(leftSphere);
      } else { leftSphere.material.map = leftTex; leftSphere.material.needsUpdate = true; }

      if(!rightSphere) {
        rightSphere = new THREE.Mesh(sphereGeom, new THREE.MeshBasicMaterial({ map: rightTex }));
        rightSphere.layers.set(2); scene.add(rightSphere);
      } else { rightSphere.material.map = rightTex; rightSphere.material.needsUpdate = true; }

      applyMode(); // mantém o modo atual ao trocar mídia
    }

    function loadImage(src){
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    function splitStereoToTextures(img){
      const w = img.width, h = img.height, half = Math.floor(h/2);
      const top = document.createElement('canvas'); top.width = w; top.height = half;
      const bot = document.createElement('canvas'); bot.width = w; bot.height = half;
      top.getContext('2d').drawImage(img, 0, 0, w, half, 0, 0, w, half);
      bot.getContext('2d').drawImage(img, 0, half, w, half, 0, 0, w, half);
      const leftTex  = new THREE.CanvasTexture(top);
      const rightTex = new THREE.CanvasTexture(bot);
      const monoTex  = leftTex.clone(); // iOS mono = metade de cima
      return { leftTex, rightTex, monoTex };
    }

    function setupTex(tex){
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = false; tex.needsUpdate = true;
    }

    function applyMode(){
      const mono = mode === 'mono' || mode === 'ios';
      const stereo = mode === 'webxr' || mode === 'cardboard';
      if (monoSphere) monoSphere.visible = mono;
      if (leftSphere) leftSphere.visible = stereo;
      if (rightSphere) rightSphere.visible = stereo;
      renderer.xr.enabled = (mode === 'webxr');
      if (!controls && mode === 'mono') camera.rotation.z = 0; // desktop: sem roll
    }

    function setModeMono(){
      if (controls) { controls.disconnect(); controls = null; }
      mode = 'mono'; applyMode();
    }

    async function setModeIOS(){
      await enableGyro(); mode = 'ios'; applyMode(); requestFullscreen();
    }

    async function setModeAndroidVR(){
      const hasXR = navigator.xr && await navigator.xr.isSessionSupported?.('immersive-vr');
      if (hasXR) {
        const btn = VRButton.createButton(renderer);
        const holder = document.getElementById('vrBtnContainer');
        holder.innerHTML = ''; holder.appendChild(btn);
        renderer.xr.addEventListener('sessionstart', () => {
          mode = 'webxr'; applyMode();
          const xrCam = renderer.xr.getCamera();
          if (xrCam && xrCam.cameras?.length >= 2) {
            xrCam.cameras[0].layers.enable(1); xrCam.cameras[0].layers.disable(2);
            xrCam.cameras[1].layers.enable(2); xrCam.cameras[1].layers.disable(1);
          }
        });
        renderer.xr.addEventListener('sessionend', () => { mode = 'mono'; applyMode(); });
      } else {
        await enableGyro(); mode = 'cardboard'; applyMode(); requestFullscreen();
      }
    }

    async function enableGyro(){
      try {
        if (typeof DeviceOrientationEvent !== 'undefined' &&
            typeof DeviceOrientationEvent.requestPermission === 'function') {
          const state = await DeviceOrientationEvent.requestPermission();
          if (state !== 'granted') console.warn('Giro não autorizado');
        }
      } catch(e) {}
      if (controls) controls.disconnect();
      controls = new DeviceOrientationControls(camera);
      controls.connect();
    }

    function requestFullscreen(){
      const el = renderer.domElement;
      if (el.requestFullscreen) el.requestFullscreen();
      else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
    }

    /* ======== BLOQUEIO DE SCROLL/PULL-TO-REFRESH *APENAS NO CANVAS* ======== */
    // Previne gestos só quando o usuário interage com a cena,
    // não atrapalha os botões.
    ['touchstart','touchmove','gesturestart','wheel'].forEach(evt => {
      canvas.addEventListener(evt, (e) => { e.preventDefault(); }, { passive: false });
    });

    /* ======== CONTROLES DESKTOP (drag, sem roll) ======== */
    let dragging=false, lastX=0, lastY=0, yaw=0, pitch=0;
    const PITCH_LIMIT = Math.PI/2 - 0.001;

    canvas.addEventListener('pointerdown', e => {
      dragging = true; lastX = e.clientX; lastY = e.clientY;
      camera.rotation.order = 'YXZ'; camera.rotation.z = 0;
      canvas.setPointerCapture(e.pointerId);
    });

    canvas.addEventListener('pointermove', e => {
      if (!dragging || controls || mode !== 'mono') return;
      const dx = e.clientX - lastX, dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      yaw -= dx * 0.005; pitch -= dy * 0.005;
      pitch = Math.max(-PITCH_LIMIT, Math.min(PITCH_LIMIT, pitch));
      camera.rotation.set(pitch, yaw, 0, 'YXZ');
    });

    canvas.addEventListener('pointerup', e => {
      dragging = false;
      try { canvas.releasePointerCapture(e.pointerId); } catch(_) {}
    });

    /* ======== RENDER / RESIZE ======== */
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    function render(){
      if (controls) controls.update();

      if (mode === 'cardboard') {
        renderer.setScissorTest(true);
        const w = window.innerWidth, h = window.innerHeight;

        camera.layers.set(1);
        renderer.setViewport(0, 0, w/2, h);
        renderer.setScissor(0, 0, w/2, h);
        renderer.render(scene, camera);

        camera.layers.set(2);
        renderer.setViewport(w/2, 0, w/2, h);
        renderer.setScissor(w/2, 0, w/2, h);
        renderer.render(scene, camera);

        renderer.setScissorTest(false);
        camera.layers.set(0);
      } else {
        if (!controls && mode === 'mono' && camera.rotation.z !== 0) camera.rotation.z = 0;
        renderer.render(scene, camera);
      }
    }
    renderer.setAnimationLoop(render);

    /* ======== UI ======== */
    const sel = document.getElementById('imgSel');
    sel.innerHTML = IMAGES.map((src, i) => `<option value="${src}">Imagem ${i+1}</option>`).join('');
    sel.addEventListener('change', async (e) => {
      currentIndex = e.target.selectedIndex;
      await loadStereo(currentIndex); // mantém o modo atual
    });

    document.getElementById('gyroBtn').addEventListener('click', setModeIOS);
    document.getElementById('vrBtn').addEventListener('click', setModeAndroidVR);

    // boot
    (async () => {
      await loadStereo(0);
      setModeMono();
    })();
  </script>
</body>
</html>
